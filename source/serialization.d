/**
 * 
 * /home/tomas/workspace/mqtt-d/source/factory.d
 * 
 * Author:
 * Tomáš Chaloupka <chalucha@gmail.com>
 * 
 * Copyright (c) 2015 ${CopyrightHolder}
 * 
 * Boost Software License 1.0 (BSL-1.0)
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license
 * grant, this restriction and the following disclaimer, must be included in all copies of the Software,
 * in whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
module mqttd.serialization;

import std.string : format;
import std.range;
import std.typecons;

import mqttd.messages;
import mqttd.traits;
import mqttd.ranges;

debug import std.stdio;

/// Serialize given Mqtt packet
void serialize(W, T)(ref W wtr, ref T item) if (isMqttPacket!T && is(W == Writer!Out, Out))
{
    static assert(hasFixedHeader!T, format("'%s' packet has no required header field!", T.stringof));

    /// Computes and sets remaining length to the package header field
    auto getRemainingLength()
    {
        uint len;
        //static if (is(T == Connect))
        //{
        //    len = item.protocolName.itemLength + item.protocolLevel.itemLength + item.connectFlags.itemLength + 
        //        item.keepAlive.itemLength + item.clientIdentifier.itemLength;
        //
        //    if (item.connectFlags.will) len += item.willTopic.itemLength + item.willMessage.itemLength;
        //    if (item.connectFlags.userName)
        //    {
        //        len += item.userName.itemLength;
        //        if (item.connectFlags.password) len += item.password.itemLength;
        //    }
        //}

        import std.typetuple;

        writeln("pwd - ", item.connectFlags.password);

        foreach(member; __traits(allMembers, T))
        {
            enum isMemberVariable = is(typeof(() {__traits(getMember, item, member) = __traits(getMember, item, member).init; }));

            static if(isMemberVariable)
            {
                foreach(attr; __traits(getAttributes, __traits(getMember, item, member)))
                {
                    enum idx = staticIndexOf!(attr, __traits(getAttributes, __traits(getMember, item, member)));
                    static if(isCondition!(typeof(attr)))
                    {
                        //check condition
                        //writeln(member, " has Condition - ", idx);
                        auto attribute = mixin(`__traits(getAttributes, T.` ~ member ~ `)`)[idx];
                        if(!attribute.cond(item)) continue;
                    }
                }

                writeln("add ", member, " - ", itemLength(__traits(getMember, item, member)));
                len += itemLength(__traits(getMember, item, member));
            }
        }

        return len;
    }

    //set remaining packet length
    item.header.length = getRemainingLength();

    //check if is valid
    try item.validate();
    catch (Exception ex) 
        throw new PacketFormatException(format("'%s' packet is not valid: %s", T.stringof, ex.msg), ex);

    //TODO: move upper
    wtr.write(item.header);

    static if (is(T == Connect))
    {
        wtr.write(item.protocolName);
        wtr.write(item.protocolLevel);
        wtr.write(item.connectFlags);
        wtr.write(item.keepAlive);
        wtr.write(item.clientIdentifier);

        if (item.connectFlags.will)
        {
            wtr.write(item.willTopic);
            wtr.write(item.willMessage);
        }
        if (item.connectFlags.userName)
        {
            wtr.write(item.userName);
            if (item.connectFlags.password) wtr.write(item.password);
        }
    }
    else assert(0, "Not implemented toBytes for " ~ T.stringof);
}

T deserialize(T, R)(ref R rdr) if (isMqttPacket!T && is(R == Reader!In, In))
{
    import std.exception : enforce;

    static assert(hasFixedHeader!T, format("'%s' packet has no required header field!", T.stringof));

    T res;

    // read header if presented
    res.header = rdr.read!FixedHeader();

    //TODO: Implement by member deserialization

    static if (is(T == Connect))
    {
        res.protocolName = rdr.read!string();
        res.protocolLevel = rdr.read!ubyte();
        res.connectFlags = rdr.read!ConnectFlags();
        res.keepAlive = rdr.read!ushort();
        res.clientIdentifier = rdr.read!string();

        if (res.connectFlags.will)
        {
            res.willTopic = rdr.read!string();
            res.willMessage = rdr.read!string();
        }
        if (res.connectFlags.userName)
        {
            res.userName = rdr.read!string();
            if (res.connectFlags.password) res.password = rdr.read!string();
        }

        enforce(rdr.empty, new PacketFormatException("There is more data available than specified in header"));
    }

    // validate initialized packet
    try res.validate();
    catch (Exception ex) 
        throw new PacketFormatException(format("'%s' packet is not valid: %s", T.stringof, ex.msg), ex);

    return res;
}

/// Connect message tests
unittest
{
    import std.array;

    auto con = Connect();
    con.clientIdentifier = "testclient";
    con.connectFlags.userName = true;
    con.userName = "user";

    auto buffer = appender!(ubyte[]);
    auto wr = writer(buffer);

    wr.serialize(con);

    assert(wr.data.length == 30);

    debug writefln("%(%.02x %)", wr.data);
    assert(wr.data == cast(ubyte[])[
            0x10, //fixed header
            0x1c, // rest is 28
            0x00, 0x04, //length of MQTT text
            0x4d, 0x51, 0x54, 0x54, // MQTT
            0x04, //protocol level
            0x80, //just user name flag
            0x00, 0x00, //zero keepalive
            0x00, 0x0a, //length of client identifier
            0x74, 0x65, 0x73, 0x74, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, //testclient text
            0x00, 0x04, //username length
            0x75, 0x73, 0x65, 0x72 //user text
        ]);

    auto data = reader(buffer.data);

    auto con2 = deserialize!Connect(data);
    assert(con == con2);
}
