/**
 * 
 * /home/tomas/workspace/mqtt-d/source/message.d
 * 
 * Author:
 * Tomáš Chaloupka <chalucha@gmail.com>
 * 
 * Copyright (c) 2015 ${CopyrightHolder}
 * 
 * Boost Software License 1.0 (BSL-1.0)
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license
 * grant, this restriction and the following disclaimer, must be included in all copies of the Software,
 * in whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
module mqttd.message;

version (unittest)
{
    import std.stdio;
}

/**
 * MQTT Control Packet type
 * 
 * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Table_2.1_-
 */
enum PacketType : ubyte
{
    /// Forbidden - Reserved
    RESERVED1   = 0,
    /// Client -> Server - Client request to connect to Server
    CONNECT     = 1,
    /// Server -> Client - Connect acknowledgment
    CONNACK     = 2,
    /// Publish message
    PUBLISH     = 3,
    /// Publish acknowledgment
    PUBACK      = 4,
    /// Publish received (assured delivery part 1)
    PUBREC      = 5,
    /// Publish release (assured delivery part 2)
    PUBREL      = 6,
    /// Publish complete (assured delivery part 3)
    PUBCOMP     = 7,
    /// Client -> Server - Client subscribe request
    SUBSCRIBE   = 8,
    /// Server -> Client - Subscribe acknowledgment
    SUBACK      = 9,
    /// Client -> Server - Unsubscribe request
    UNSUBSCRIBE = 10,
    /// Server -> Client - Unsubscribe acknowledgment
    UNSUBACK    = 11,
    /// Client -> Server - PING request
    PINGREQ     = 12,
    /// Server -> Client - PING response
    PINGRESP    = 13,
    /// Client -> Server - Client is disconnecting
    DISCONNECT  = 14,
    /// Forbidden - Reserved
    RESERVED2   = 15
}

/**
 * Indicates the level of assurance for delivery of an Application Message
 * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Table_3.11_-
 */
enum QoSLevel : ubyte
{
    /// At most once delivery
    AtMostOnce = 0x0,
    /// At least once delivery
    AtLeastOnce = 0x1,
    /// Exactly once delivery
    ExactlyOnce = 0x2,
    /// Reserved – must not be used
    Reserved = 0x3
}

/**
 * Exception thrown when package format is somehow malformed
 */
class PacketFormatException : Exception
{
    this(string msg = null, Throwable next = null)
    {
        super(msg, next);
    }
}

/**
 * The remaining bits [3-0] of byte 1 in the fixed header contain flags specific to each MQTT Control Packet type
 * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Table_2.2_-
 */
struct Flags
{
    import std.traits : isIntegral;

    /// Duplicate delivery of a PUBLISH Control Packet
    bool dup;

    /// Quality Of Service for a message
    QoSLevel qos;
    
    /// PUBLISH Retain flag 
    bool retain;
    
    @property ubyte flags() const
    {
        return cast(ubyte)((dup ? 0x08 : 0x00) | (retain ? 0x01 : 0x00) | (qos << 1));
    }
    @property void flags(ubyte value)
    {
        dup = (value & 0x08) == 0x08;
        retain = (value & 0x01) == 0x01;
        qos = cast(QoSLevel)((value >> 1) & 0x03);
    }

    this(bool dup, QoSLevel qos, bool retain)
    {
        this.dup = dup;
        this.retain = retain;
        this.qos = qos;
    }

    this(T)(T value) if(isIntegral!T)
    {
        dup = (value & 0x08) == 0x08;
        retain = (value & 0x01) == 0x01;
        qos = cast(QoSLevel)((value >> 1) & 0x03);
    }

    alias flags this;
    
    unittest
    {
        assert(Flags(true, QoSLevel.Reserved, true) == 0x0F);
        Flags flags = 0x0F;
        assert(flags.dup);
        assert(flags.retain);
        assert(flags.qos == QoSLevel.Reserved);
    }
}

/**
 * Each MQTT Control Packet contains a fixed header.
 * 
 * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Figure_2.2_-
 */
struct FixedHeader
{
    import std.range;

    /// Represented as a 4-bit unsigned value
    PacketType type;

    /// The remaining bits [3-0] of byte 1 in the fixed header contain flags specific to each MQTT Control Packet type
    Flags flags;

    /**
     * The Remaining Length is the number of bytes remaining within the current packet, 
     * including data in the variable header and the payload. 
     * The Remaining Length does not include the bytes used to encode the Remaining Length.
     */
    int length;

    void toBytes(scope void delegate(ubyte) sink) const
    {
        sink(cast(ubyte)(type << 4 | flags));

        int tmp = length;
        do
        {
            byte digit = tmp % 128;
            tmp /= 128;
            if (tmp > 0) digit |= 0x80;
            sink(digit);
        } while (tmp > 0);
    }

    static FixedHeader fromBytes(R)(R range) if (isInputRange!R && is(ElementType!R == ubyte))
    {
        import std.exception;

        FixedHeader header;

        enforce(!range.empty);
        ubyte first = range.front;
        range.popFront();

        header.type = cast(PacketType)(first >> 4);
        header.flags = first;

        int multiplier = 1;
        ubyte digit;
        do
        {
            enforce(!range.empty);
            digit = range.front;
            range.popFront();
            header.length += ((digit & 127) * multiplier);
            multiplier *= 128;
            if (multiplier > 128*128*128) throw new PacketFormatException("Malformed remaining length");
        } while ((digit & 128) != 0);

        return header;
    }
    
    unittest
    {
        import std.array;

        auto header = FixedHeader(PacketType.CONNECT, Flags(0x0F), 255);

        auto bytes = appender!(ubyte[]);
        header.toBytes(a => bytes.put(a));

        assert(bytes.data.length == 3);
        assert(bytes.data[0] == 0x1F);
        assert(bytes.data[1] == 0xFF);
        assert(bytes.data[2] == 0x01);

        header.length = 10;
        bytes.clear();
        header.toBytes(a => bytes.put(a));
        assert(bytes.data.length == 2);
        assert(bytes.data[0] == 0x1F);
        assert(bytes.data[1] == 0x0A);

        header = FixedHeader.fromBytes(cast(ubyte[])[0x1F, 0x0A]);
        assert(header.type == PacketType.CONNECT);
        assert(header.flags == 0x0F);
        assert(header.length == 10);

        header = FixedHeader.fromBytes(cast(ubyte[])[0x20, 0x80, 0x02]);
        assert(header.type == PacketType.CONNACK);
        assert(header.flags == 0x00);
        assert(header.length == 256);
    }
}

struct Connect
{
    enum flags = 0b0000; // Reserved

    FixedHeader header;


}

struct ConnAck
{
    enum flags  = 0b0000; // Reserved
    FixedHeader header;

}

struct Publish
{
    FixedHeader header;

}

struct PubAck
{
    enum flags = 0b0000; // Reserved
    FixedHeader header;

}

struct PubRect
{
    enum flags = 0b0000; // Reserved
    FixedHeader header;

}

struct PubRel
{
    enum flags = 0b0010; // Reserved
    FixedHeader header;

}

struct PubComp
{
    enum flags = 0b0000; // Reserved
    FixedHeader header;

}

struct Subscribe
{
    enum flags = 0b0010; // Reserved
    FixedHeader header;

}

struct SubAck
{
    enum flags = 0b0000; // Reserved
    FixedHeader header;

}

struct Unsubscribe
{
    enum flags = 0b0010; // Reserved
    FixedHeader header;

}

struct UnsubAck
{
    enum flags = 0b0000; // Reserved
    FixedHeader header;

}

struct PingReq
{
    enum flags = 0b0000; // Reserved
    FixedHeader header;

}

struct PingResp
{
    enum flags = 0b0000; // Reserved
    FixedHeader header;

}

struct Disconnect
{
    enum flags = 0b0000; // Reserved
    FixedHeader header;

}

