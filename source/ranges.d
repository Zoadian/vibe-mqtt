/**
 * 
 * /home/tomas/workspace/mqtt-d/source/serializer.d
 * 
 * Author:
 * Tomáš Chaloupka <chalucha@gmail.com>
 * 
 * Copyright (c) 2015 ${CopyrightHolder}
 * 
 * Boost Software License 1.0 (BSL-1.0)
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license
 * grant, this restriction and the following disclaimer, must be included in all copies of the Software,
 * in whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
module mqttd.ranges;

import std.range;
import mqttd.traits;
import mqttd.messages;

debug import std.stdio;
debug import std.string : format;

void write(R, T)(auto ref R output, T val) if (canSerializeTo!(R))
{
    writer(output).write(val);
}

auto writer(R)(auto ref R output) if (canSerializeTo!(R))
{
    return Writer!R(output);
}

template read(T)
{
    auto read(R)(auto ref R input) if (canDeserializeFrom!(R))
    {
        return reader(input).read!T();
    }
}

auto reader(R)(auto ref R input) if (canDeserializeFrom!(R))
{
    return Reader!R(input);
}

struct Writer(R) if (canSerializeTo!(R))
{
    this(R writer)
    {
        _output = writer;
    }

    void put(ubyte val)
    {
        _output.put(val);
    }

    static if(__traits(hasMember, R, "data"))
    {
        @property auto data()
        {
            return _output.data();
        }
    }

    void write(T)(T val) if (canWrite!T)
    {
        static if (is(T == FixedHeader)) // first to avoid implicit conversion to ubyte
        {
            put(val.flags);

            int tmp = val.length;
            do
            {
                byte digit = tmp % 128;
                tmp /= 128;
                if (tmp > 0) digit |= 0x80;
                put(digit);
            } while (tmp > 0);
        }
        else static if (is(T:ubyte))
        {
            put(val);
        }
        else static if (is(T:ushort))
        {
            put(cast(ubyte) (val >> 8));
            put(cast(ubyte) val);
        }
        else static if (is(T:string))
        {
            import std.string : representation;

            enforce(val.length <= 0xFF, "String too long: ", val);

            write((cast(ushort)val.length));
            foreach(b; val.representation) put(b);
        }
    }

private:
    
    R _output;

    static assert(isOutputRange!(Writer, ubyte), "Writer is not Output range!");
}

struct Reader(R) if (canDeserializeFrom!(R))
{
    this(R input)
    {
        _input = input;
    }

    @property ubyte front()
    {
        //debug writef("%.02x ", _input.front);
        return cast(ubyte)_input.front;
    }
    
    @property bool empty()
    {
        //debug if (_input.empty) writeln();
        return _input.empty;
    }
    
    void popFront()
    {
        _input.popFront();
        //debug writefln("Pop: %s", empty? "empty" : format("%.02x", front));
    }

    T read(T)() if (canRead!T)
    {
        T res = void;
        static if (is(T == FixedHeader)) // first to avoid implicit conversion to ubyte
        {
            res.flags = read!ubyte();
            res.length = 0;
            
            uint multiplier = 1;
            ubyte digit;
            do
            {
                digit = read!ubyte();
                res.length += ((digit & 127) * multiplier);
                multiplier *= 128;
                if (multiplier > 128*128*128) throw new PacketFormatException("Malformed remaining length");
            } while ((digit & 128) != 0);
        }
        else static if (is(T:ubyte))
        {
            res = cast(T)front;
            popFront();
        }
        else static if (is(T:ushort))
        {
            res = cast(ushort) (read!ubyte() << 8);
            res |= cast(ushort) read!ubyte();
        }
        else static if (is(T:string))
        {
            import std.array;
            import std.algorithm : map;

            auto length = read!ushort();
            res = (&this).takeExactly(length).map!(a => cast(immutable char)a).array;
        }

        return res;
    }
    
private:
    
    R _input;
    
    static assert(isInputRange!(Reader) && is(ElementType!Reader == ubyte), "Reader is not Input range!");
}

/// ubyte tests
unittest
{
    import std.array;
    
    ubyte id = 10;
    auto bytes = appender!(ubyte[]);
    bytes.write(id);
    
    assert(bytes.data.length == 1);
    assert(bytes.data[0] == 0x0A);
    
    id = 0x2B;
    bytes.clear();
    
    bytes.write(id);
    
    assert(bytes.data.length == 1);
    assert(bytes.data[0] == 0x2B);
    
    id = [0x11].read!ubyte();
    assert(id == 0x11);

    id = read!ubyte([0x22]);
    assert(id == 0x22);
}

/// ushort tests
unittest
{
    import std.array;
    
    ushort id = 1;
    auto bytes = appender!(ubyte[]);
    bytes.write(id);
    
    assert(bytes.data.length == 2);
    assert(bytes.data[0] == 0);
    assert(bytes.data[1] == 1);
    
    id = 0x1A2B;
    bytes.clear();
    
    bytes.write(id);
    
    assert(bytes.data.length == 2);
    assert(bytes.data[0] == 0x1A);
    assert(bytes.data[1] == 0x2B);
    
    id = [0x11, 0x22].read!ushort();
    assert(id == 0x1122);
}

/// string tests
unittest
{
    import std.array;
    import std.string : representation;
    import std.range;
    
    auto name = "test";
    auto bytes = appender!(ubyte[]);
    bytes.write(name);
    
    assert(bytes.data.length == 6);
    assert(bytes.data[0] == 0);
    assert(bytes.data[1] == 4);
    assert(bytes.data[2..$] == "test".representation);
    
    name = (cast(ubyte[])[0x00, 0x0A] ~ "randomname".representation).read!string();
    assert(name == "randomname");
}

/// Fixed header tests
unittest
{
    import std.array;

    assert(FixedHeader(PacketType.RESERVED1, true, QoSLevel.Reserved, true) == 0x0F);

    FixedHeader header = 0x0F;
    assert(header.type == PacketType.RESERVED1);
    assert(header.dup);
    assert(header.retain);
    assert(header.qos == QoSLevel.Reserved);

    header = FixedHeader(PacketType.CONNECT, 0x0F, 255);

    auto bytes = appender!(ubyte[]);
    bytes.write(header);

    assert(bytes.data.length == 3);
    assert(bytes.data[0] == 0x1F);
    assert(bytes.data[1] == 0xFF);
    assert(bytes.data[2] == 0x01);

    header.length = 10;
    bytes.clear();
    bytes.write(header);
    assert(bytes.data.length == 2);
    assert(bytes.data[0] == 0x1F);
    assert(bytes.data[1] == 0x0A);

    header = [0x1F, 0x0A].read!FixedHeader();
    assert(header.type == PacketType.CONNECT);
    assert(header.flags == 0x1F);
    assert(header.length == 10);

    header = [0x20, 0x80, 0x02].read!FixedHeader();
    assert(header.type == PacketType.CONNACK);
    assert(header.flags == 0x20);
    assert(header.length == 256);
}

/// ConnectFlags test
unittest
{
    import std.array;
    
    ConnectFlags flags = ConnectFlags(128);

    auto bytes = appender!(ubyte[]);
    bytes.write(flags);
    
    assert(bytes.data.length == 1);
    assert(bytes.data[0] == 128);
    
    flags = [2].read!ConnectFlags();
    assert(flags.cleanSession);
}