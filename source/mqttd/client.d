/**
 * 
 * /home/tomas/workspace/mqtt-d/source/mqttd/client.d
 * 
 * Author:
 * Tomáš Chaloupka <chalucha@gmail.com>
 * 
 * Copyright (c) 2015 Tomáš Chaloupka
 * 
 * Boost Software License 1.0 (BSL-1.0)
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license
 * grant, this restriction and the following disclaimer, must be included in all copies of the Software,
 * in whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
module mqttd.client;

debug import std.stdio;

import mqttd.messages;
import mqttd.serialization;
import vibe.core.log;
import vibe.core.net: TCPConnection;
import vibe.core.stream;
import vibe.core.task;
import std.datetime;

struct Settings
{
    string host = "127.0.0.1";
    ushort port = 1883u;
    string clientId = "vibe-d.mqtt";
    string userName = null;
    string password = null;
}

class MqttClient
{
    import std.array : Appender;

    this(Settings settings)
    {
        import std.socket : Socket;

        _settings = settings;
        _sendBuffer = Serializer!(Appender!(ubyte[]))();
        if (_settings.clientId.length == 0) _settings.clientId = Socket.hostName;
        debug writeln(Socket.hostName);
    }

    final void connect()
    in { assert(_con is null ? true : !_con.connected); }
    body
    {
        import vibe.core.net: connectTCP;
        import vibe.core.core: runTask;

        _con = connectTCP(_settings.host, _settings.port);
        _listener = runTask(&listener);

        version(MqttDebug) logDebug("MQTT Broker Connecting");

        auto con = Connect();
        con.clientIdentifier = _settings.clientId;
        if (_settings.userName.length > 0)
        {
            con.flags.userName = true;
            con.userName = "user";
            if (_settings.password.length > 0)
            {
                con.flags.password = true;
                con.password = "user";
            }
        }

        send(con);
    }

    final void send(T)(auto ref T msg)
    {
        _sendBuffer.clear();
        _sendBuffer.serialize(msg);

        if (_con.connected)
        {
            debug writefln("OUT: %(%.02x %)", _sendBuffer.data);
            _con.write(_sendBuffer.data);
        }
    }

private:
    Settings _settings;
    TCPConnection _con;
    Task _listener;
    Serializer!(Appender!(ubyte[])) _sendBuffer;

final:
    void listener()
    in { assert(_con && _con.connected); }
    body
    {
        import vibe.core.log: logError;
        import vibe.core.core: sleep;

        auto buffer = Appender!(ubyte[])();

        size_t bytesRead;
        FixedHeader readFixedHeader()
        {
            ubyte[] buf = new ubyte[](4);
            if( !_con.empty )
            {
                auto least_size = _con.leastSize(); //Blocks until data is available
                auto str = _con.peek();
                if(str.length == 0)
                {
                    _con.read(buf);
                    str = buf;
                    bytesRead = buf.length;
                }
                else if(str.length > 4)
                {
                    str.length = 4;
                }

                buf = cast(ubyte[])str;
                if(str.length < 4)
                {
                    buf.length = 4;
                    _con.read(buf[str.length..$]);
                }
                
                buffer.put(buf);

                debug writefln("IN: %(%.02x %)", str);
            }

            return FixedHeader(buf[0]);
        }

        version(MqttDebug) logDebug("MQTT Entering listening loop");
        
        while(_con.connected)
        {
            try
            {
                auto header = readFixedHeader();
            }
            catch(Exception err)
            {
                logError(err.toString);
                
                break;
            }

            sleep(dur!"msecs"(10));

            buffer.clear();
        }

        version(MqttDebug) logDebug("MQTT Exiting listening loop");
    }
}

