/**
 *
 * /home/tomas/workspace/mqtt-d/source/mqttd/client.d
 *
 * Author:
 * Tomáš Chaloupka <chalucha@gmail.com>
 *
 * Copyright (c) 2015 Tomáš Chaloupka
 *
 * Boost Software License 1.0 (BSL-1.0)
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license
 * grant, this restriction and the following disclaimer, must be included in all copies of the Software,
 * in whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
module mqttd.client;

debug import std.stdio;

import mqttd.traits;
import mqttd.messages;
import mqttd.serialization;

import vibe.core.log;
import vibe.core.net: TCPConnection;
import vibe.core.stream;
import vibe.core.sync;
import vibe.core.task;
import vibe.core.concurrency;
import vibe.utils.array : FixedRingBuffer;

import std.datetime;
import std.exception;
import std.string : format;
import std.traits;
import std.typecons : Flag, Yes, No;

enum MQTT_BROKER_DEFAULT_PORT = 1883u;
enum MQTT_BROKER_DEFAULT_SSL_PORT = 8883u;
enum MQTT_SENDQUEUE_SIZE = 1000u; /// maximal number of packets storable in the session send queue
enum MQTT_WAITQUEUE_SIZE = 1000u; /// maximal number of packets storable in the session waiting queue
enum MQTT_MAX_PACKET_ID = ushort.max; /// maximal packet id (0..65536) - defined by MQTT protocol
enum MQTT_CLIENT_ID = "vibe-mqtt"; /// default client identifier
enum MQTT_RETRY_DELAY = 10_000u; /// delay for retry publish, subscribe and unsubscribe for QoS Level 1 or 2 [ms]
enum MQTT_RETRY_ATTEMPTS = 3u; /// max publish, subscribe and unsubscribe retry for QoS Level 1 or 2

alias SessionContainer = FixedRingBuffer!(PacketContext);

/// MqttClient settings
struct Settings
{
	string host = "127.0.0.1"; /// message broker address
	ushort port = MQTT_BROKER_DEFAULT_PORT; /// message broker port
	string clientId = MQTT_CLIENT_ID; /// Client Id to identify within message broker (must be unique)
	string userName = null; /// optional user name to login with
	string password = null; /// user password
	int retryDelay = MQTT_RETRY_DELAY;
	int retryAttempts = MQTT_RETRY_ATTEMPTS; /// how many times will client try to resend QoS1 and QoS2 packets
	bool cleanSession = true; /// clean client and server session state on connect
	size_t sendQueueSize = MQTT_SENDQUEUE_SIZE; /// number of packets storable in the session sending queue (default is 1_000)
	size_t waitQueueSize = MQTT_WAITQUEUE_SIZE; /// number of packets storable in the session waiting queue (default is 1_000)
}

/// MQTT packet state
enum PacketState
{
	queuedQos0, /// QOS = 0, Message queued
	queuedQos1, /// QOS = 1, Message queued
	queuedQos2, /// QOS = 2, Message queued
	waitForPuback, /// QOS = 1, PUBLISH sent, wait for PUBACK
	waitForPubrec, /// QOS = 2, PUBLISH sent, wait for PUBREC
	waitForPubrel, /// QOS = 2, PUBREC sent, wait for PUBREL
	waitForPubcomp, /// QOS = 2, PUBREL sent, wait for PUBCOMP
	sendPubrec, /// QOS = 2, start first phase handshake send PUBREC
	sendPubrel, /// QOS = 2, start second phase handshake send PUBREL
	sendPubcomp, /// QOS = 2, end second phase handshake send PUBCOMP
	sendPuback, /// QOS = 1, PUBLISH received, send PUBACK
	queuedSubscribe, /// Subscribe message queued
	queuedUnsubscribe, /// Unsubscribe message queued
	waitForSuback, /// (QOS = 1), SUBSCRIBE sent, wait for SUBACK
	waitForUnsuback, /// (QOS = 1), UNSUBSCRIBE sent, wait for UNSUBACK
}

/// Origin of the stored packet
enum PacketOrigin
{
	client, /// originated from this client
	broker /// originated from broker
}

/// Context for MQTT packet stored in Session
struct PacketContext
{
	static this()
	{
		_event = createManualEvent();
		setUsed(0);
	}

	~this()
	{
		decRef();
	}

	this(T)(T packet, PacketState state, PacketOrigin origin = PacketOrigin.client)
	{
		assert(refcount is null);
		assert(_event !is null);

		refcount = new int(1);

		this.timestamp = Clock.currTime;
		this.state = state;
		this.origin = origin;
		if (origin == PacketOrigin.client && state != PacketState.queuedQos0)
			packet.packetId = nextPacketId();

		static if (is(T == Publish))
		{
			this.packetType = PacketType.PUBLISH;
			this.publish = packet;
		}
		else static if (is(T == Subscribe))
		{
			this.packetType = PacketType.SUBSCRIBE;
			this.subscribe = packet;
		}
		else static if (is(T == Unsubscribe))
		{
			this.packetType = PacketType.UNSUBSCRIBE;
			this.unsubscribe = packet;
		}
		else static assert(0, "Unsupported type");
	}

	this(this)
	{
		if (refcount !is null) *refcount += 1;
	}

	PacketState state; /// MQTT packet state
	public uint attempt; /// Attempt (for retry)
	public SysTime timestamp; /// Timestamp (for retry)

	PacketType packetType; /// MQTT packet content
	PacketOrigin origin; /// MQTT packet origin

	/// MQTT packet id
	@property ushort packetId()
	{
		switch (packetType)
		{
			case PacketType.PUBLISH:
				return publish.packetId;
			case PacketType.SUBSCRIBE:
				return subscribe.packetId;
			case PacketType.UNSUBSCRIBE:
				return unsubscribe.packetId;
			default:
				return 0;
		}
	}

	/// Context can hold different packet types
	union
	{
		Publish publish; /// Publish packet
		Subscribe subscribe; /// Subscribe packet
		Unsubscribe unsubscribe; /// Unsubscribe packet
	}

private:
	int* refcount;

	void decRef()
	{
		if (refcount !is null)
		{
			if ((*refcount -= 1) == 0)
			{
				refcount = null;
				if (this.origin == PacketOrigin.client && this.packetId)
					setUnused(this.packetId);
				version (unittest) {} //HACK: For some reason unittest will segfault when emiting
				else
				{
					assert(_event !is null);
					_event.emit();
				}
			}
		}
	}

static:
	/// Gets next packet id. If the session is full it won't return till there is free space again
	@property auto nextPacketId()
	out (result)
	{
		assert(result, "packet id can't be 0!");
	}
	body
	{
		import std.algorithm : any;

		do
		{
			if (!_idUsage[].any!(a => a != size_t.max)())
			{
				version (MqttDebug) logDiagnostic("MQTT all packet ids in use - waiting");
				this._event.wait();
				continue;
			}

			//packet id can't be 0!
			_packetId = cast(ushort)((_packetId % MQTT_MAX_PACKET_ID) != 0 ? _packetId + 1 : 1);
		}
		while (isUsed(_packetId));

		version (MqttDebug) if (_packetId == 1) logDiagnostic("ID Overflow");

		setUsed(_packetId);

		return _packetId;
	}

	pragma(inline, true) auto isUsed(ushort id) { return (_idUsage[getIdx(id)] & getIdxValue(id)) == getIdxValue(id); }
	pragma(inline, true) auto setUsed(ushort id)
	{
		assert(!isUsed(id));
		_idUsage[getIdx(id)] |= getIdxValue(id);
	}
	pragma(inline, true) auto setUnused(ushort id)
	{
		assert(id != 0);
		if (id == 0) return;
		assert(isUsed(id));
		_idUsage[getIdx(id)] ^= getIdxValue(id);
	}
	pragma(inline, true) auto getIdx(ushort id) { return id / (size_t.sizeof*8); }
	pragma(inline, true) auto getIdxValue(ushort id) { return cast(size_t)(1uL << (id % (size_t.sizeof*8))); }

	ManualEvent _event;
	ushort _packetId = 0u;
	size_t[(MQTT_MAX_PACKET_ID+1)/(size_t.sizeof*8)] _idUsage; //1024 * 64 = 65536 => id usage flags storage
}

/// Queue storage helper for session
private struct SessionQueue(Flag!"send" send)
{
	this(Settings settings)
	{
		_event = createManualEvent();

		static if (send) _packets = SessionContainer(settings.sendQueueSize);
		else _packets = SessionContainer(settings.waitQueueSize);
	}

	@disable this();
	@disable this(this) {}

	/**
	 * Adds packet to Session
	 * If the session is full the call will be blocked until there is space again.
	 * Also if there is no free packetId to use, it will be blocked until it is.
	 *
	 * Params:
	 * 		packet = packet to be sent (can be Publish, Subscribe or Unsubscribe)
	 * 		state = initial packet state
	 * 		origin = origin of the packet (session stores control packets from broker too)
	 */
	auto add(T)(auto ref T packet, PacketState state, PacketOrigin origin = PacketOrigin.client)
		if (is(T == Publish) || is(T == Subscribe) || is(T == Unsubscribe))
	{
		return add(PacketContext(packet, state, origin));
	}

	/// ditto
	auto add(PacketContext ctx)
	in
	{
		assert(ctx.packetId || ctx.state == PacketState.queuedQos0, "Invalid packet context state");
	}
	body
	{
		while (_packets.full)
		{
			static if (send)
			{
				if (ctx.state == PacketState.queuedQos0)
				{
					version (MqttDebug) logDiagnostic("MQTT SendQueueFull - dropping QoS0 publish msg");
					return cast(ushort)0;
				}
				else version (MqttDebug) logDiagnostic("MQTT SendQueueFull (packet#: %s) - waiting", this.length);
			}
			else version (MqttDebug) logDiagnostic("MQTT WaitQueueFull (packet#: %s) - waiting", this.length);

			_event.wait();
		}

		static if (send) assert(!_packets.full, format("SEND %s: state=%s, id=%s", ctx.packetType, ctx.state, ctx.packetId));
		else assert(!_packets.full, format("WAIT %s: state=%s, id=%s", ctx.packetType, ctx.state, ctx.packetId));
		_packets.put(ctx);

		_event.emit();

		return ctx.packetId;
	}

	/// Waits until the session state is changed
	auto wait()
	{
		return _event.wait();
	}

	/// Waits until the session state is changed or timeout is reached
	auto wait(Duration timeout)
	{
		return _event.wait(timeout, _event.emitCount);
	}

	/// Manually emit session state change to all listeners
	auto emit()
	{
		return _event.emit();
	}

	/// Removes the stored PacketContext
	void removeAt(size_t idx)
	{
		assert(idx < this.length);

		_packets.removeAt(_packets[idx..idx+1]);
		_event.emit();
	}

	ref PacketContext opIndex(size_t idx)
	{
		assert(idx < this.length);
		return _packets[idx];
	}

	/// Finds package context stored in session
	auto canFind(ushort packetId, out PacketContext* ctx, out size_t idx, PacketState[] state...)
	{
		import std.algorithm;

		size_t i;
		foreach(ref c; _packets)
		{
			if(c.packetId == packetId && (!state.length || std.algorithm.canFind!(a => a == c.state)(state)))
			{
				ctx = &c;
				idx = i;
				return true;
			}
			++i;
		}

		return false;
	}

	@property ref PacketContext front()
	{
		return _packets.front();
	}

	void popFront()
	{
		assert(!_packets.empty);
		_packets.popFront();
		_event.emit();
	}

	@property bool empty() const
	{
		return _packets.empty;
	}

	/// Number of packets to process
	@property auto length() const @safe @nogc pure
	{
		return _packets.length;
	}

nothrow:

	/// Clears cached messages
	void clear()
	{
		_packets.clear();
		_event.emit();
	}

private:
	ManualEvent _event;
	SessionContainer _packets;
}

/// MQTT session status holder
struct Session
{
	alias WaitQueue = SessionQueue!(No.send);
	alias SendQueue = SessionQueue!(Yes.send);

	this(Settings settings)
	{
		_waitQueue = WaitQueue(settings);
		_sendQueue = SendQueue(settings);
	}

	@disable this(this) {}

	@property ref WaitQueue waitQueue()
	{
		return _waitQueue;
	}

	@property ref SendQueue sendQueue()
	{
		return _sendQueue;
	}

	auto clear()
	{
		this._waitQueue.clear();
		this._sendQueue.clear();
	}

private:
	/// Packets to handle
	WaitQueue _waitQueue;
	SendQueue _sendQueue;
}

unittest
{
	PacketContext ctx;
	assert(ctx.getIdx(1) == 0);
	assert(ctx.getIdx(64) == 1);
	assert(ctx.getIdxValue(1) == ctx.getIdxValue(65));
	assert(ctx.getIdxValue(63) == 0x8000000000000000);
	assert(ctx.getIdx(128) == 2);
	ctx.setUsed(1);
	assert(ctx.isUsed(1));
	ctx.setUsed(64);
	assert(ctx.isUsed(64));
	ctx.setUnused(64);
	assert(!ctx.isUsed(64));
	assert(ctx.isUsed(1));
	ctx.setUnused(1);

	foreach(i; 1..size_t.sizeof*8) ctx.setUsed(cast(ushort)i);
	assert(ctx._idUsage[0] == size_t.max);
}

/// MQTT Client implementation
class MqttClient
{
	import std.array : Appender;
	import vibe.core.core : Timer, createTimer;

	this(Settings settings)
	{
		import std.socket : Socket;

		_settings = settings;
		if (_settings.clientId.length == 0) // set clientId if not provided
			_settings.clientId = Socket.hostName;

		_readBuffer.capacity = 4 * 1024;
		_session = Session(settings);
		_conAckTimer = createTimer(
			{
				version (MqttDebug) logWarn("MQTT ConAck not received, disconnecting");
				this.disconnect();
			});
	}

	final
	{
		/// Connects to the specified broker and sends it the Connect packet
		void connect()
		in { assert(_con is null ? true : !_con.connected); }
		body
		{
			import vibe.core.net: connectTCP;
			import vibe.core.core: runTask;

			//cleanup before reconnects
			_readBuffer.clear();
			if (_settings.cleanSession ) _session.clear();

			_con = connectTCP(_settings.host, _settings.port);
			_listener = runTask(&listener);
			_dispatcher = runTask(&dispatcher);
			_onDisconnectCalled = false;

			version(MqttDebug) logDebug("MQTT Broker Connecting");

			auto con = Connect();
			con.clientIdentifier = _settings.clientId;
			con.flags.cleanSession = _settings.cleanSession;
			if (_settings.userName.length > 0)
			{
				con.flags.userName = true;
				con.userName = _settings.userName;
				if (_settings.password.length > 0)
				{
					con.flags.password = true;
					con.password = _settings.password;
				}
			}

			this.send(con);
			_conAckTimer.rearm(5.seconds);
		}

		/// Sends Disconnect packet to the broker and closes the underlying connection
		void disconnect()
		in { assert(!(_con is null)); }
		body
		{
			version(MqttDebug) logDebug("MQTT Disconnecting from Broker");

			if (_con.connected)
			{
				this.send(Disconnect());
				_con.flush();
				_con.close();

				_session.waitQueue.emit();
				_session.sendQueue.emit();

				if(Task.getThis !is _listener)
					_listener.join;
			}
		}

		/**
		 * Return true, if client is in a connected state
		 */
		@property bool connected() const
		{
			return _con !is null && _con.connected;
		}

		/**
		 * Publishes the message on the specified topic
		 *
		 * Params:
		 *     topic = Topic to send message to
		 *     payload = Content of the message
		 *     qos = Required QoSLevel to handle message (default is QoSLevel.AtMostOnce)
		 *     retain = If true, the server must store the message so that it can be delivered to future subscribers
		 *
		 */
		void publish(T)(in string topic, in T payload, QoSLevel qos = QoSLevel.QoS0, bool retain = false)
			if (isSomeString!T || (isArray!T && is(ForeachType!T : ubyte)))
		{
			auto pub = Publish();
			pub.header.qos = qos;
			pub.header.retain = retain;
			pub.topic = topic;
			pub.payload = cast(ubyte[]) payload;

			_session.sendQueue.add(pub, qos == QoSLevel.QoS0 ?
				PacketState.queuedQos0 :
				(qos == QoSLevel.QoS1 ? PacketState.queuedQos1 : PacketState.queuedQos2));
		}

		/**
		 * Subscribes to the specified topics
		 *
		 * Params:
		 *      topics = Array of topic filters to subscribe to
		 *      qos = This gives the maximum QoS level at which the Server can send Application Messages to the Client.
		 *
		 */
		void subscribe(const string[] topics, QoSLevel qos = QoSLevel.QoS0)
		{
			import std.algorithm : map;
			import std.array : array;

			auto sub = Subscribe();
			sub.topics = topics.map!(a => Topic(a, qos)).array;

			_session.sendQueue.add(sub, PacketState.queuedSubscribe);
		}

		/**
		 * Unsubscribes from the specified topics
		 *
		 * Params:
		 *      topics = Array of topic filters to unsubscribe from
		 *
		 */
		void unsubscribe(const string[] topics...)
		{
			import std.algorithm : map;
			import std.array : array;

			auto unsub = Unsubscribe();
			unsub.topics = topics.dup;

			_session.sendQueue.add(unsub, PacketState.queuedUnsubscribe);
		}
	}

	/// Response to connection request
	void onConnAck(ConnAck packet)
	{
		version(MqttDebug) logDebug("MQTT onConnAck - %s", packet);

		if(packet.returnCode == ConnectReturnCode.ConnectionAccepted)
		{
			version(MqttDebug) logDebug("MQTT Connection accepted");
			_conAckTimer.stop();
		}
		else throw new Exception(format("Connection refused: %s", packet.returnCode));
	}

	/// Response to PingReq
	void onPingResp(PingResp packet)
	{
		version(MqttDebug) logDebug("MQTT onPingResp - %s", packet);
	}

	// QoS1 handling

	/// Publish request acknowledged - QoS1
	void onPubAck(PubAck packet)
	{
		version(MqttDebug) logDebug("MQTT onPubAck - %s", packet);

		PacketContext* ctx;
		size_t idx;
		if(_session.waitQueue.canFind(packet.packetId, ctx, idx, PacketState.waitForPuback))
		{
			//treat the PUBLISH Packet as “unacknowledged” until corresponding PUBACK received
			_session.waitQueue.removeAt(idx);
		}
		else version (MqttDebug) logDiagnostic("MQTT onPubAck not found");
	}

	// QoS2 handling - S:Publish, R: PubRec, S: PubRel, R: PubComp

	/// Publish request acknowledged - QoS2
	void onPubRec(PubRec packet)
	{
		version(MqttDebug) logDebug("MQTT onPubRec - %s", packet);

		PacketContext* ctx;
		size_t idx;
		// Both states to handle possible resends of unanswered PubRec packets
		if(_session.waitQueue.canFind(packet.packetId, ctx, idx, PacketState.waitForPubrec, PacketState.waitForPubcomp))
		{
			//MUST send a PUBREL packet when it receives a PUBREC packet from the receiver.
			this.send(PubRel(ctx.packetId)); //to avoid lock on filled sendQueue
			ctx.state = PacketState.waitForPubcomp;
			_session.waitQueue.emit();
		}
		else version (MqttDebug) logDiagnostic("MQTT onPubRec not found");
	}

	/// Confirmation that message was succesfully delivered (Sender side)
	void onPubComp(PubComp packet)
	{
		version(MqttDebug) logDebug("MQTT onPubComp - %s", packet);

		PacketContext* ctx;
		size_t idx;
		if(_session.waitQueue.canFind(packet.packetId, ctx, idx, PacketState.waitForPubcomp))
		{
			//treat the PUBREL packet as “unacknowledged” until it has received the corresponding PUBCOMP packet from the receiver.
			_session.waitQueue.removeAt(idx);
		}
		else version (MqttDebug) logDiagnostic("MQTT onPubComp not found");
	}

	void onPubRel(PubRel packet)
	{
		version(MqttDebug) logDebug("MQTT onPubRel - %s", packet);

		PacketContext* ctx;
		size_t idx;
		if(_session.waitQueue.canFind(packet.packetId, ctx, idx, PacketState.waitForPubrel))
		{
			//MUST respond to a PUBREL packet by sending a PUBCOMP packet containing the same Packet Identifier as the PUBREL.
			this.send(PubRel(ctx.packetId)); //to avoid lock on filled sendQueue
			_session.waitQueue.removeAt(idx);
		}
		else version (MqttDebug) logDiagnostic("MQTT onPubRel not found");
	}

	/// Message was received from broker
	void onPublish(Publish packet)
	{
		version(MqttDebug) logDebug("MQTT onPublish - %s", packet);

		//MUST respond with a PUBACK Packet containing the Packet Identifier from the incoming PUBLISH Packet
		if (packet.header.qos == QoSLevel.QoS1)
		{
			_session.sendQueue.add(packet, PacketState.sendPuback, PacketOrigin.broker);
		}
		else if (packet.header.qos == QoSLevel.QoS2)
		{
			_session.sendQueue.add(packet, PacketState.sendPubrec, PacketOrigin.broker);
		}
	}

	/// Message was succesfully delivered to broker
	void onSubAck(SubAck packet)
	{
		version(MqttDebug) logDebug("MQTT onSubAck - %s", packet);

		PacketContext* ctx;
		size_t idx;
		if(_session.waitQueue.canFind(packet.packetId, ctx, idx, PacketState.waitForSuback))
		{
			_session.waitQueue.removeAt(idx);
		}
	}

	/// Confirmation that unsubscribe request was successfully delivered to broker
	void onUnsubAck(UnsubAck packet)
	{
		version(MqttDebug) logDebug("MQTT onUnsubAck - %s", packet);

		PacketContext* ctx;
		size_t idx;
		if(_session.waitQueue.canFind(packet.packetId, ctx, idx, PacketState.waitForUnsuback))
		{
			_session.waitQueue.removeAt(idx);
		}
	}

	/// Client was disconnected from broker
	void onDisconnect()
	{
		version(MqttDebug) logDebug("MQTT onDisconnect");
	}

private:
	Settings _settings;
	TCPConnection _con;
	Session _session;
	Task _listener, _dispatcher;
	Serializer!(Appender!(ubyte[])) _sendBuffer;
	FixedRingBuffer!ubyte _readBuffer;
	ubyte[] _packetBuffer;
	bool _onDisconnectCalled;
	Timer _conAckTimer;

final:

	/// Processes data in read buffer. If whole packet is presented, it delegates it to handler
	void proccessData(in ubyte[] data)
	{
		import mqttd.serialization;
		import std.range;

		version(MqttDebug) logDebugV("MQTT IN: %(%.02x %)", data);

		if (_readBuffer.freeSpace < data.length) // ensure all fits to the buffer
			_readBuffer.capacity = _readBuffer.capacity + data.length;
		_readBuffer.put(data);

		if (_readBuffer.length > 0)
		{
			// try read packet header
			FixedHeader header = _readBuffer[0]; // type + flags

			// try read remaining length
			uint pos;
			uint multiplier = 1;
			ubyte digit;
			do
			{
				if (++pos >= _readBuffer.length) return; // not enough data
				digit = _readBuffer[pos];
				header.length += ((digit & 127) * multiplier);
				multiplier *= 128;
				if (multiplier > 128*128*128) throw new PacketFormatException("Malformed remaining length");
			} while ((digit & 128) != 0);

			if (_readBuffer.length < header.length + pos + 1) return; // not enough data

			// we've got the whole packet to handle
			_packetBuffer.length = 1 + pos + header.length; // packet type byte + remaining size bytes + remaining size
			_readBuffer.read(_packetBuffer); // read whole packet from read buffer

			with (PacketType)
			{
				final switch (header.type)
				{
					case CONNACK:
						onConnAck(_packetBuffer.deserialize!ConnAck());
						break;
					case PINGRESP:
						onPingResp(_packetBuffer.deserialize!PingResp());
						break;
					case PUBACK:
						onPubAck(_packetBuffer.deserialize!PubAck());
						break;
					case PUBREC:
						onPubRec(_packetBuffer.deserialize!PubRec());
						break;
					case PUBREL:
						onPubRel(_packetBuffer.deserialize!PubRel());
						break;
					case PUBCOMP:
						onPubComp(_packetBuffer.deserialize!PubComp());
						break;
					case PUBLISH:
						onPublish(_packetBuffer.deserialize!Publish());
						break;
					case SUBACK:
						onSubAck(_packetBuffer.deserialize!SubAck());
						break;
					case UNSUBACK:
						onUnsubAck(_packetBuffer.deserialize!UnsubAck());
						break;
					case CONNECT:
					case SUBSCRIBE:
					case UNSUBSCRIBE:
					case PINGREQ:
					case DISCONNECT:
					case RESERVED1:
					case RESERVED2:
						throw new Exception(format("Unexpected packet type '%s'", header.type));
				}
			}
		}
	}

	/// loop to receive packets
	void listener()
	in { assert(_con && _con.connected); }
	body
	{
		import vibe.core.log: logError;

		version(MqttDebug) logDebug("MQTT Entering listening loop");

		auto buffer = new ubyte[4096];

		while (_con.connected && !_con.empty)
		{
			auto size = _con.leastSize;
			if (size > 0)
			{
				if (size > buffer.length) size = buffer.length;
				_con.read(buffer[0..size]);
				proccessData(buffer[0..size]);
			}
		}

		if (!_con.connected) callOnDisconnect();

		version(MqttDebug) logDebug("MQTT Exiting listening loop");
	}

	/// loop to dispatch in session stored packets
	void dispatcher()
	in { assert(_con && _con.connected); }
	body
	{
		version(MqttDebug) logDebug("MQTT Entering dispatch loop");

		bool con = true;
		while (true)
		{
			// wait for session state change or timeout
			_session.sendQueue.wait(_settings.retryDelay.msecs);

			if (!_con.connected) break;
			if (_conAckTimer.pending) continue; //wait for ConAck before sending any messages

			while (_session.sendQueue.length)
			{
				version (MqttDebug) logDebugV("MQTT Packets in session: send=%s, wait=%s", _session.sendQueue.length, _session.waitQueue.length);
				auto ctx = _session.sendQueue.front;
				final switch (ctx.state)
				{
					// QoS0 handling - S:Publish, S:forget
					case PacketState.queuedQos0: // just send it
						//Sender request QoS0
						assert(ctx.packetType == PacketType.PUBLISH);
						assert(ctx.origin == PacketOrigin.client);
						this.send(ctx.publish);
						break;

					// QoS1 handling - S:Publish, R:PubAck
					case PacketState.queuedQos1:
						//Sender request QoS1
						//treat the Packet as “unacknowledged” until the corresponding PUBACK packet received
						assert(ctx.packetType == PacketType.PUBLISH);
						assert(ctx.publish.header.qos == QoSLevel.QoS1);
						assert(ctx.origin == PacketOrigin.client);
						this.send(ctx.publish);
						ctx.state = PacketState.waitForPuback;
						_session.waitQueue.add(ctx);
						break;
					case PacketState.sendPuback:
						assert(ctx.packetType == PacketType.PUBLISH);
						assert(ctx.publish.header.qos == QoSLevel.QoS1);
						assert(ctx.origin == PacketOrigin.broker);
						auto ack = PubAck();
						ack.packetId = ctx.publish.packetId;
						this.send(ack);
						break;

					// QoS2 handling - S:Publish, R: PubRec, S: PubRel, R: PubComp
					case PacketState.queuedQos2:
						//Sender request QoS2
						//treat the PUBLISH packet as “unacknowledged” until it has received the corresponding PUBREC packet from the receiver.
						assert(ctx.packetType == PacketType.PUBLISH);
						assert(ctx.publish.header.qos == QoSLevel.QoS2);
						assert(ctx.origin == PacketOrigin.client);
						this.send(ctx.publish);
						ctx.state = PacketState.waitForPubrec;
						_session.waitQueue.add(ctx);
						break;
					case PacketState.sendPubrel:
						//Sender reaction to PubRec
						//PUBREL packet MUST contain the same Packet Identifier as the original PUBLISH packet.
						assert(ctx.packetType == PacketType.PUBLISH);
						assert(ctx.publish.header.qos == QoSLevel.QoS2);
						assert(ctx.origin == PacketOrigin.client);
						PubRel pubRel;
						pubRel.packetId = ctx.publish.packetId;
						this.send(pubRel);
						ctx.state = PacketState.waitForPubcomp;
						_session.waitQueue.add(ctx);
						break;
					case PacketState.sendPubrec:
						//Receiver reaction to Publish
						//MUST respond with a PUBREC containing the Packet Identifier from the incoming PUBLISH Packet
						assert(ctx.packetType == PacketType.PUBLISH);
						assert(ctx.publish.header.qos == QoSLevel.QoS2);
						assert(ctx.origin == PacketOrigin.broker);
						PubRec pubRec;
						pubRec.packetId = ctx.publish.packetId;
						this.send(pubRec);
						ctx.state = PacketState.waitForPubrel;
						_session.waitQueue.add(ctx);
						break;
					case PacketState.sendPubcomp:
						//Receiver reaction to Pubrel
						//MUST respond to a PUBREL packet by sending a PUBCOMP packet containing the same Packet Identifier as the PUBREL.
						assert(ctx.packetType == PacketType.PUBLISH);
						assert(ctx.publish.header.qos == QoSLevel.QoS2);
						assert(ctx.origin == PacketOrigin.broker);
						PubComp pubComp;
						pubComp.packetId = ctx.publish.packetId;
						this.send(pubComp);
						break;

					// Subscribe handling
					case PacketState.queuedSubscribe:
						assert(ctx.packetType == PacketType.SUBSCRIBE);
						assert(ctx.origin == PacketOrigin.client);
						this.send(ctx.subscribe);
						ctx.state = PacketState.waitForSuback; // change to next state
						_session.waitQueue.add(ctx);
						break;

					// Unsubscribe handling
					case PacketState.queuedUnsubscribe:
						assert(ctx.packetType == PacketType.UNSUBSCRIBE);
						assert(ctx.origin == PacketOrigin.client);
						this.send(ctx.unsubscribe);
						ctx.state = PacketState.waitForUnsuback; // change to next state
						_session.waitQueue.add(ctx);
						break;

					case PacketState.waitForPuback:
					case PacketState.waitForPubrec:
					case PacketState.waitForPubcomp:
					case PacketState.waitForPubrel:
					case PacketState.waitForSuback:
					case PacketState.waitForUnsuback:
						assert(0, "Invalid state");
				}

				//remove from sendQueue
				_session.sendQueue.popFront;
			}
		}

		if (!_con.connected) callOnDisconnect();

		version(MqttDebug) logDebug("MQTT Exiting dispatch loop");
	}

	auto send(T)(auto ref T msg) if (isMqttPacket!T)
	{
		_sendBuffer.clear(); // clear to write new
		_sendBuffer.serialize(msg);

		if (_con.connected)
		{
			version(MqttDebug)
			{
				logDebug("MQTT OUT: %s", msg);
				logDebugV("MQTT OUT: %(%.02x %)", _sendBuffer.data);
			}
			_con.write(_sendBuffer.data);
			return true;
		}
		else return false;
	}

	auto callOnDisconnect()
	{
		if (!_onDisconnectCalled)
		{
			_onDisconnectCalled = true;
			onDisconnect();
		}
	}
}

unittest
{
	auto s = Session(Settings());

	auto pub = Publish();
	auto id = s.sendQueue.add(pub, PacketState.waitForPuback);

	assert(s.sendQueue.length == 1);

	PacketContext* ctx;
	size_t idx;
	assert(id != 0);
	assert(s.sendQueue.canFind(id, ctx, idx));
	assert(idx == 0);
	assert(s.sendQueue.length == 1);

	assert(ctx.packetType == PacketType.PUBLISH);
	assert(ctx.state == PacketState.waitForPuback);
	assert(ctx.attempt == 0);
	assert(ctx.publish != Publish.init);
	assert(ctx.timestamp != SysTime.init);

	s.sendQueue.removeAt(idx);
	assert(s.sendQueue.length == 0);
}
