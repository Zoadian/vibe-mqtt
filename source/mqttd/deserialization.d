/**
 * 
 * C:\Projects\mqtt-d\source\mqttd\deserialization.d
 * 
 * Author:
 * Tomáš Chaloupka <chalucha@gmail.com>
 * 
 * Copyright (c) 2015 ${CopyrightHolder}
 * 
 * Boost Software License 1.0 (BSL-1.0)
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy
 * of the software and accompanying documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative
 * works of the Software, and to permit third-parties to whom the Software is furnished to do so,
 * all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license
 * grant, this restriction and the following disclaimer, must be included in all copies of the Software,
 * in whole or in part, and all derivative works of the Software, unless such copies or derivative works
 * are solely in the form of machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 * DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
module mqttd.deserialization;

import std.format : format;
import std.range;
import mqttd.traits;
import mqttd.messages;

debug import std.stdio;

auto deserializer(R)(auto ref R input) if (canDeserializeFrom!(R))
{
    return Deserializer!R(input);
}

struct Deserializer(R) if (canDeserializeFrom!(R))
{
    this(R input)
    {
        _input = input;
    }

    @property ubyte front()
    {
        //debug writef("%.02x ", _input.front);
        return cast(ubyte)_input.front;
    }
    
    @property bool empty()
    {
        //debug if (_input.empty) writeln();
        return _input.empty;
    }
    
    void popFront()
    {
        _input.popFront();
        if(_remainingLen > 0) _remainingLen--; //decrease remaining length set from fixed header
        //debug writefln("Pop: %s", empty? "empty" : format("%.02x", front));
    }

    T deserialize(T)() if (isMqttPacket!T)
    {
        import std.typetuple;
        import std.exception : enforce;

        static assert(hasFixedHeader!T, format("'%s' packet has no required header field!", T.stringof));

        T res;

        foreach(memberName; __traits(allMembers, T))
        {
            alias memberType = typeof(__traits(getMember, res, memberName));
            enum isMemberVariable = is(typeof(() {__traits(getMember, res, memberName) = __traits(getMember, res, memberName).init; }));
            
            static if(isMemberVariable)
            {
                //special case for Connect packet
                static if (is(T == Connect))
                {
                    static if (memberName == "willTopic" || memberName == "willMessage")
                    {
                        if (!res.flags.will) continue;
                    }
                    else static if (memberName == "userName") { if (!res.flags.userName) continue; }
                    else static if (memberName == "password") { if (!res.flags.password) continue; }
                }

                //debug writeln("processing ", memberName);
                __traits(getMember, res, memberName) = read!memberType();
            }
        }

        enforce(empty, "Some data are remaining after packet deserialization!");
        
        // validate initialized packet
        try res.validate();
        catch (Exception ex) 
            throw new PacketFormatException(format("'%s' packet is not valid: %s", T.stringof, ex.msg), ex);
        
        return res;
    }

private:
    R _input;
    uint _remainingLen;

    T read(T)() if (canRead!T)
    {
        T res = void;
        static if (is(T == FixedHeader)) // first to avoid implicit conversion to ubyte
        {
            res.flags = read!ubyte();
            res.length = 0;
            
            uint multiplier = 1;
            ubyte digit;
            do
            {
                digit = read!ubyte();
                res.length += ((digit & 127) * multiplier);
                multiplier *= 128;
                if (multiplier > 128*128*128) throw new PacketFormatException("Malformed remaining length");
            } while ((digit & 128) != 0);
            
            //set remaining length for calculations
            _remainingLen = res.length;
        }
        else static if (is(T:ubyte))
        {
            res = cast(T)front;
            popFront();
        }
        else static if (is(T:ushort))
        {
            res = cast(ushort) (read!ubyte() << 8);
            res |= cast(ushort) read!ubyte();
        }
        else static if (is(T:string))
        {
            import std.array;
            import std.algorithm : map;
            
            auto length = read!ushort();
            res = (&this).takeExactly(length).map!(a => cast(immutable char)a).array;
        }
        else static if (is(T == Topic))
        {
            res.filter = read!string();
            res.qos = read!QoSLevel();
        }
        else static if (isDynamicArray!T)
        {
            res = T.init;
            while(_remainingLen > 0) // read to end
            {
                res ~= read!(ElementType!T)();
            }
        }
        
        return res;
    }
}

